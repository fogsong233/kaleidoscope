module;
#include "llvm/IR/BasicBlock.h"
#include "llvm/ADT/APFloat.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Type.h"
#include "llvm/IR/Verifier.h"
#include "llvm/Analysis/LoopAnalysisManager.h"
#include "llvm/Analysis/CGSCCPassManager.h"
#include "llvm/IR/PassInstrumentation.h"
#include "llvm/Support/TargetSelect.h"

#include "llvm/Passes/PassBuilder.h"
#include "llvm/Passes/StandardInstrumentations.h"

#include "llvm/Transforms/InstCombine/InstCombine.h"
#include "llvm/Transforms/Scalar.h"
#include "llvm/Transforms/Scalar/GVN.h"
#include "llvm/Transforms/Scalar/Reassociate.h"
#include "llvm/Transforms/Scalar/SimplifyCFG.h"

#include "./headers/KaleidoscopeJIT.h"
export module kaleidoscope:codegen;
import std;
import :ast;
import :util;

#define uptr std::unique_ptr

using llvm::orc::KaleidoscopeJIT;

export namespace Kaleidoscope::Codegen {
uptr<llvm::LLVMContext> theContext;
uptr<llvm::IRBuilder<>> IRBuilder;
uptr<llvm::Module> theModule;
std::map<std::string, llvm::Value*> nameValues;
std::map<std::string, uptr<AST::Prototype>> functionProtos;

uptr<KaleidoscopeJIT> theJIT;

namespace opt {
uptr<llvm::FunctionPassManager> theFuncPM;
uptr<llvm::LoopAnalysisManager> theLoopAM;
uptr<llvm::FunctionAnalysisManager> theFuncAM;
uptr<llvm::CGSCCAnalysisManager> theCGAM;
uptr<llvm::ModuleAnalysisManager> theMdAM;
uptr<llvm::PassInstrumentationCallbacks> thePICb;
uptr<llvm::StandardInstrumentations> theSI;
}  // namespace opt

void InitializeModuleAndManager() {
    using namespace llvm;
    theContext = std::make_unique<LLVMContext>();
    theModule = std::make_unique<Module>("my jit", *theContext);
    theModule->setDataLayout(theJIT->getDataLayout());

    IRBuilder = std::make_unique<llvm::IRBuilder<>>(*theContext);

    // init for optimize
    // Create new pass and analysis managers.
    opt::theFuncPM = std::make_unique<FunctionPassManager>();
    opt::theFuncAM = std::make_unique<FunctionAnalysisManager>();
    opt::theLoopAM = std::make_unique<LoopAnalysisManager>();
    opt::theCGAM = std::make_unique<CGSCCAnalysisManager>();
    opt::theMdAM = std::make_unique<ModuleAnalysisManager>();
    opt::thePICb = std::make_unique<PassInstrumentationCallbacks>();
    opt::theSI = std::make_unique<StandardInstrumentations>(*theContext, true);
    opt::theSI->registerCallbacks(*opt::thePICb, opt::theMdAM.get());

    // Add transform passes.
    // Do simple "peephole" optimizations and bit-twiddling optzns.
    // eg: x*2 => x + 2
    opt::theFuncPM->addPass(InstCombinePass());
    // Reassociate expressions. eg: (x * 2) * 4 => x * 8
    opt::theFuncPM->addPass(ReassociatePass());
    // Eliminate Common SubExpressions.
    opt::theFuncPM->addPass(GVNPass());
    // Simplify the control flow graph (deleting unreachable blocks, etc).
    opt::theFuncPM->addPass(SimplifyCFGPass());

    // Register analysis passes used in these transform passes.
    PassBuilder pb;
    pb.registerFunctionAnalyses(*opt::theFuncAM);
    pb.registerModuleAnalyses(*opt::theMdAM);
    pb.crossRegisterProxies(*opt::theLoopAM, *opt::theFuncAM, *opt::theCGAM, *opt::theMdAM);
}

llvm::Function* getFunction(std::string name) {
    // First, see if the function has already been added to the current module.
    if(auto* func = theModule->getFunction(name))
        return func;

    // If not, check whether we can codegen the declaration from some existing
    // prototype.

    auto funcProto = functionProtos.find(name);
    if(funcProto != functionProtos.end()) {
        return funcProto->second->codegen();
    }

    // If no existing prototype exists, return null.
    return nullptr;
}
}  // namespace Kaleidoscope::Codegen

export namespace Kaleidoscope {

using namespace Codegen;

using namespace llvm;

void initLLVM() {
    using namespace llvm;

    llvm::InitializeNativeTarget();
    llvm::InitializeNativeTargetAsmPrinter();
    llvm::InitializeNativeTargetAsmParser();
    // jit
    theJIT = Util::exitOnErr(KaleidoscopeJIT::Create());

    InitializeModuleAndManager();
}

#define CodegenFor(ExprName) llvm::Value* ExprName::codegen()

CodegenFor(AST::NumberExpr) {
    return llvm::ConstantFP::get(*theContext, llvm::APFloat(this->val));
}

CodegenFor(AST::VariableExpr) {
    // from function parameters
    auto* value = nameValues[this->name];
    if(!value) {
        Util::logErr<llvm::Value>("Unkown variable name");
    }
    return value;
}

CodegenFor(AST::BinaryExpr) {
    auto* lv = this->lhs->codegen();
    auto* rv = this->rhs->codegen();
    if(!lv || !rv) {
        return nullptr;
    }

    switch(this->op) {
        case '+': return IRBuilder->CreateFAdd(lv, rv, "addtmp");
        case '-': return IRBuilder->CreateFSub(lv, rv, "subtmp");
        case '*': return IRBuilder->CreateFMul(lv, rv, "multmp");
        case '<':
            lv = IRBuilder->CreateFCmpULT(lv, rv, "cmptmp");
            // Convert bool 0/1 to double 0.0 or 1.0
            return IRBuilder->CreateUIToFP(lv, Type::getDoubleTy(*theContext), "booltmp");
        default: return Util::logErr<llvm::Value>("invalid binary operator");
    }
}

CodegenFor(AST::CallExpr) {
    auto* calleeFunc = getFunction(this->callee);
    if(!calleeFunc) {
        return Util::logErr<llvm::Value>("Unknown function to call");
    }
    if(this->args.size() != calleeFunc->arg_size()) {
        return Util::logErr<llvm::Value>("Invalid argument numbers");
    }

    std::vector<llvm::Value*> argsVec;

    for(const auto& arg: this->args) {
        argsVec.push_back(arg->codegen());
        if(!argsVec.back())
            return nullptr;
    }
    // Call the function with the generated arguments
    return IRBuilder->CreateCall(calleeFunc, argsVec, "calltmp");
}

#undef CodegenFor

llvm::Function* AST::Prototype::codegen() {
    std::vector<llvm::Type*> doublesArgs(this->args.size(), Type::getDoubleTy(*theContext));
    auto* funcTy =
        llvm::FunctionType::get(llvm::Type::getDoubleTy(*theContext), doublesArgs, false);
    auto* func = llvm::Function::Create(funcTy,
                                        llvm::Function::ExternalLinkage,
                                        this->name,
                                        // register in the moduleâ€º
                                        theModule.get());
    // Set names for all arguments.
    unsigned index = 0;
    for(auto& arg: func->args()) {
        arg.setName(this->args[index++]);
    }
    return func;
};

llvm::Function* AST::Function::codegen() {

    auto& proto = *(this->proto);
    functionProtos[proto.getName()] = std::move(this->proto);
    auto* theFunc = getFunction(proto.name);

    if(!theFunc) {
        theFunc = this->proto->codegen();
    }

    if(!theFunc) {
        return nullptr;
    }

    if(!theFunc->empty()) {
        return Util::logErr<llvm::Function>(
            std::format("Function {} can not be redefined", this->proto->name).c_str());
    }

    // gen the block
    auto* basicBlock = llvm::BasicBlock::Create(*theContext, "entry", theFunc);
    IRBuilder->SetInsertPoint(basicBlock);

    nameValues.clear();
    for(auto& arg: theFunc->args()) {
        nameValues[std::string(arg.getName())] = &arg;
    }
    if(auto* retVal = this->body->codegen()) {
        IRBuilder->CreateRet(retVal);
        // Validate the generated code, checking for consistency.
        llvm::verifyFunction(*theFunc);
        opt::theFuncPM->run(*theFunc, *opt::theFuncAM);
        return theFunc;
    }
    // error reading body, remove function
    theFunc->eraseFromParent();
    return nullptr;
}
};  // namespace Kaleidoscope

#undef uptr
