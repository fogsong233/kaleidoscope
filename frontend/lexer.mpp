export module kaleidoscope:lexer;
import std;

export namespace Kaleidoscope::Token {
// The lexer returns tokens [0-255] if it is an unknown character, otherwise one
// of these for known things.
enum KnownToken {
    tEOF = -1,

    // command
    tDEF = -2,
    tEXTERN = -3,

    // primary
    tIDENTIFIER = -4,
    tNUMBER = -5,

};
}  // namespace Kaleidoscope::Token

namespace Kaleidoscope {

static std::string _identifierStr;  // Filled in if tok_identifier
static double _numVal;              // Filled in if tok_number

export const std::string& getIdentifierStr() {
    return _identifierStr;
}

export const double getNumVal() {
    return _numVal;
}

export int strParseToToken(std::istream& stream) {
    static int lastChar = ' ';
    while(std::isspace(lastChar))
        lastChar = stream.get();

    if(std::isalpha(lastChar)) {
        _identifierStr = lastChar;
        while(lastChar = stream.get(), std::isalnum(lastChar))
            _identifierStr += lastChar;

        if(_identifierStr == "def") {
            return Token::tDEF;
        }
        if(_identifierStr == "extern") {
            return Token::tEXTERN;
        }
        return Token::tIDENTIFIER;
    }

    if(std::isdigit(lastChar) || lastChar == '.') {
        std::string numStr{static_cast<char>(lastChar)};
        while(lastChar = stream.get(), std::isdigit(lastChar) || lastChar == '.') {
            numStr += lastChar;
        }
        _numVal = std::strtod(numStr.c_str(), nullptr);  // TODO: parse valid check
        return Token::tNUMBER;
    }

    // comment
    if(lastChar == '#') {
        do
            lastChar = stream.get();
        while(lastChar != '\r' && lastChar != std::char_traits<char>::eof() && lastChar != '\n');
    }

    if(lastChar == std::char_traits<char>::eof()) {
        lastChar = ' ';
        return Token::tEOF;
    }

    // otherwise, normal ascii char
    auto thisChar = lastChar;
    lastChar = stream.get();
    return thisChar;
}

}  // namespace Kaleidoscope
